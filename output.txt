==== src/components/QRCodeGenerator.tsx ====

import React, { useState } from 'react';
import { QRCodeSVG } from 'qrcode.react';

interface QRCodeGeneratorProps {
  url: string;
  name: string;
  onNameChange: (newName: string) => void;
}

const QRCodeGenerator: React.FC<QRCodeGeneratorProps> = ({ url, name, onNameChange }) => {
  const handleDownload = () => {
    const svg = document.getElementById('qr-code') as HTMLElement;
    const svgData = new XMLSerializer().serializeToString(svg);
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    const img = new Image();
    img.onload = () => {
      canvas.width = img.width;
      canvas.height = img.height + 30;
      ctx?.drawImage(img, 0, 0);

      if (ctx) {
        ctx.font = '16px Arial';
        ctx.fillStyle = 'black';
        ctx.textAlign = 'center';
        ctx.fillText(name, canvas.width / 2, canvas.height - 10);
      }

      const pngFile = canvas.toDataURL('image/png');
      const downloadLink = document.createElement('a');
      downloadLink.download = `${name || 'qrcode'}.png`;
      downloadLink.href = pngFile;
      downloadLink.click();
    };
    img.src = 'data:image/svg+xml;base64,' + btoa(svgData);
  };

  return (
    <div className="flex flex-col items-center space-y-4">
      <QRCodeSVG id="qr-code" value={url} size={200} />
      <p className="text-lg font-semibold">Scan to view card list</p>
      <input
        type="text"
        value={name}
        onChange={(e) => onNameChange(e.target.value)}
        placeholder="Enter QR code name"
        className="border border-gray-300 rounded px-3 py-2 w-full max-w-xs"
      />
      <button
        onClick={handleDownload}
        className="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded"
      >
        Download QR Code
      </button>
    </div>
  );
};

export default QRCodeGenerator;

==== src/App.tsx ====

import React, { useState, useEffect } from 'react';
import { FileUploader } from './components/FileUploader';
import CardGrid from './components/CardGrid.tsx';
import QRCodeGenerator from './components/QRCodeGenerator';
import { getCardsFromLocalAPI } from './utils/api';
import { Card } from './types';

const API_URL = import.meta.env.VITE_API_URL || 'http://localhost:5000';
console.log('API_URL:', API_URL); // Add this line for debugging

function App() {
  const [cards, setCards] = useState<Card[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [listId, setListId] = useState<string | null>(null);
  const [listName, setListName] = useState('');
  const [localIpAddress, setLocalIpAddress] = useState('');

  useEffect(() => {
    const rootElement = document.getElementById('root');
    const cardListId = rootElement?.getAttribute('data-card-list-id');
    if (cardListId) {
      fetchCardList(cardListId);
    } else {
      const urlParams = new URLSearchParams(window.location.search);
      const id = urlParams.get('id');
      if (id) {
        fetchCardList(id);
      }
    }
    fetchLocalIpAddress();
  }, []);

  const fetchLocalIpAddress = async () => {
    try {
      const response = await fetch(`${API_URL}/get-local-ip`);
      if (response.ok) {
        const data = await response.json();
        console.log('Fetched local IP address:', data.ip);
        setLocalIpAddress(data.ip);
      } else {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      console.error('Error fetching local IP address:', error);
      setLocalIpAddress('localhost'); // Fallback to localhost if unable to fetch IP
    }
  };

  const fetchCardList = async (id: string) => {
    setIsLoading(true);
    try {
      const response = await fetch(`${API_URL}/api/card-list/${id}`);
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      setCards(data.cards);
      setListId(id);
      setListName(data.name);
    } catch (error) {
      console.error('Error fetching card list:', error);
      alert('Error fetching card list. Please try again.');
    } finally {
      setIsLoading(false);
    }
  };

  const handleFileUpload = async (file: File) => {
    setIsLoading(true);
    try {
      const formData = new FormData();
      formData.append('file', file);

      const response = await fetch(`${API_URL}/api/upload`, {
        method: 'POST',
        body: formData,
      });

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }

      const result = await response.json();
      setCards(result.cards);
      setListId(result.id);
      setListName(result.name);
    } catch (error) {
      console.error('Error processing file:', error);
      alert('Error processing file. Please try again.');
    } finally {
      setIsLoading(false);
    }
  };

  const handleNameChange = async (newName: string) => {
    setListName(newName);
    if (listId) {
      try {
        const response = await fetch(`${API_URL}/api/card-list/${listId}`, {
          method: 'PATCH',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({ name: newName }),
        });

        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
      } catch (error) {
        console.error('Error updating list name:', error);
        alert('Error updating list name. Please try again.');
      }
    }
  };

  return (
    <div className="min-h-screen bg-gray-100 p-8">
      <h1 className="text-4xl font-bold text-center mb-8">MTG Card Uploader</h1>
      {cards.length === 0 ? (
        <div className="max-w-md mx-auto">
          <FileUploader onFileUpload={handleFileUpload} />
        </div>
      ) : (
        <div className="space-y-8">
          {listId && (
            <QRCodeGenerator
              url={`http://${localIpAddress}:5000/card-list/${listId}`}
              name={listName}
              onNameChange={handleNameChange}
            />
          )}
          <CardGrid cards={cards} />
        </div>
      )}
      {isLoading && (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center">
          <div className="bg-white p-4 rounded-lg shadow-lg">
            <p className="text-lg font-semibold">Loading...</p>
          </div>
        </div>
      )}
    </div>
  );
}

export default App;

==== main.py ====

from flask import Flask, jsonify, request, render_template_string, redirect
from flask_sqlalchemy import SQLAlchemy
from flask_cors import CORS
from dotenv import load_dotenv
import os
import uuid
from werkzeug.utils import secure_filename
import csv
import requests
from sqlalchemy import event, text, CHAR
from sqlalchemy.exc import SQLAlchemyError, OperationalError
from sqlalchemy.orm import relationship
import json
import logging
import qrcode
from io import BytesIO
import base64
import socket

# Load environment variables from .env.flask
load_dotenv('.env.flask')

app = Flask(__name__)
CORS(app)  # Enable CORS for all routes
logging.basicConfig(level=logging.DEBUG, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
# Configure SQLAlchemy
app.config['SQLALCHEMY_DATABASE_URI'] = os.getenv('DATABASE_URI')
app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False
app.config['SECRET_KEY'] = os.getenv('SECRET_KEY')

db = SQLAlchemy(app)

# Define models
class CardList(db.Model):
    __tablename__ = 'card_lists'
    id = db.Column(CHAR(36), primary_key=True)
    name = db.Column(db.String(255), nullable=False)
    items = relationship('CardListItem', back_populates='card_list', cascade="all, delete-orphan")

class CardListItem(db.Model):
    __tablename__ = 'card_list_items'
    list_id = db.Column(CHAR(36), db.ForeignKey('card_lists.id'), primary_key=True)
    card_id = db.Column(db.Text, primary_key=True)
    name = db.Column(db.String(255), nullable=False)
    set_code = db.Column(db.String(10), nullable=False)
    set_name = db.Column(db.String(255), nullable=False)
    collector_number = db.Column(db.String(20), nullable=False)
    image_uris = db.Column(db.JSON)
    price = db.Column(db.Numeric(10, 2))
    foil_price = db.Column(db.Numeric(10, 2))
    quantity = db.Column(db.Integer, default=1)  # New field for quantity
    card_list = relationship('CardList', back_populates='items')

def setup_db_events(app):
    @event.listens_for(db.engine, "engine_connect")
    def ping_connection(connection, branch):
        if branch:
            return  # Skip if this is a nested transaction or sub-connection

        save_should_close_with_result = connection.should_close_with_result
        connection.should_close_with_result = False

        try:
            connection.scalar(text("SELECT 1"))
        except Exception:
            app.logger.warning("Database connection failed. Invalidating connection.")
            connection.invalidate()
        finally:
            connection.should_close_with_result = save_should_close_with_result

# Global error handler for database errors
@app.errorhandler(SQLAlchemyError)
def handle_db_error(error):
    app.logger.error(f"Database error: {str(error)}")
    return jsonify({'error': 'An error occurred while processing your request.'}), 500

@app.errorhandler(OperationalError)
def handle_operational_error(error):
    app.logger.error(f"Database connection error: {str(error)}")
    return jsonify({'error': 'Database connection error. Please try again later.'}), 503

# API routes
@app.route('/api/card-list/<string:id>', methods=['GET'])
def get_card_list(id):
    try:
        result = db.session.execute(text("""
            SELECT cl.id, cl.name, c.*
            FROM card_lists cl
            LEFT JOIN card_list_items cli ON cl.id = cli.list_id
            LEFT JOIN cards c ON cli.card_id = c.id
            WHERE cl.id = :list_id
        """), {'list_id': id}).fetchall()

        if not result:
            return jsonify({'error': 'Card list not found'}), 404

        card_list = {
            'id': result[0].id,
            'name': result[0].name,
            'cards': []
        }

        for row in result:
            if row.card_id:
                card_list['cards'].append({
                    'id': row.card_id,
                    'name': row.name,
                    'set': row.set,
                    'set_name': row.set_name,
                    'image_uris': json.loads(row.image_uris) if row.image_uris else {},
                    'price': float(row.price) if row.price else 0,
                    'foil_price': float(row.foil_price) if row.foil_price else 0,
                    'collector_number': row.collector_number,
                    'quantity': row.quantity
                })

        return jsonify(card_list)
    except Exception as e:
        db.session.rollback()
        app.logger.error(f"Error: {str(e)}")
        return jsonify({'error': 'An error occurred'}), 500

@app.route('/api/card-list/<string:id>', methods=['PATCH'])
def update_card_list_name(id):
    try:
        card_list = db.session.query(CardList).get(id)
        if not card_list:
            return jsonify({'error': 'Card list not found'}), 404

        data = request.json
        if 'name' in data:
            card_list.name = data['name']
            db.session.commit()
            return jsonify({'message': 'Card list name updated successfully'})
        return jsonify({'error': 'Name not provided'}), 400
    except Exception as e:
        db.session.rollback()
        app.logger.error(f"Error: {str(e)}")
        return jsonify({'error': 'An error occurred'}), 500

@app.route('/api/upload', methods=['POST'])
def upload_file():
    app.logger.info("Upload request received")
    app.logger.debug(f"Request files: {request.files}")
    app.logger.debug(f"Request form: {request.form}")

    if 'file' not in request.files:
        app.logger.error("No file part in the request")
        return jsonify({'error': 'No file part'}), 400

    file = request.files['file']
    app.logger.info(f"File received: {file.filename}")

    if file.filename == '':
        app.logger.error("No selected file")
        return jsonify({'error': 'No selected file'}), 400

    if file and file.filename.endswith('.csv'):
        try:
            filename = secure_filename(file.filename)
            file_path = os.path.join('/tmp', filename)
            file.save(file_path)
            app.logger.info(f"File saved to {file_path}")

            cards = process_csv(file_path)
            app.logger.info(f"Processed {len(cards)} cards from CSV")

            card_data = fetch_card_data(cards)
            app.logger.info(f"Fetched data for {len(card_data)} cards")

            list_id = str(uuid.uuid4())
            list_name = f"Card List {list_id[:8]}"
            new_list = CardList(id=list_id, name=list_name)
            db.session.add(new_list)
            app.logger.info(f"Created new CardList: {list_id}")

            for card_info in card_data:
                try:
                    existing_item = CardListItem.query.filter_by(list_id=list_id, card_id=card_info['id']).first()
                    if existing_item:
                        existing_item.quantity += 1
                    else:
                        card_list_item = CardListItem(
                            list_id=list_id,
                            card_id=card_info['id'],
                            name=card_info['name'],
                            set_code=card_info['set'],
                            set_name=card_info['set_name'],
                            collector_number=card_info['collector_number'],
                            image_uris=json.dumps(card_info['image_uris']),
                            price=card_info['price'],
                            foil_price=card_info['foil_price'],
                            quantity=1
                        )
                        db.session.add(card_list_item)
                except SQLAlchemyError as e:
                    app.logger.error(f"Error adding CardListItem: {str(e)}")
                    db.session.rollback()
                    return jsonify({'error': f'Error adding card to list: {str(e)}'}), 500

            try:
                db.session.commit()
                app.logger.info(f"Committed changes to database")
            except SQLAlchemyError as e:
                app.logger.error(f"Error committing to database: {str(e)}")
                db.session.rollback()
                return jsonify({'error': f'Error saving to database: {str(e)}'}), 500

            os.remove(file_path)
            app.logger.info(f"Temporary file {file_path} removed")

            return jsonify({
                'id': list_id,
                'name': list_name,
                'cards': card_data
            })
        except Exception as e:
            db.session.rollback()
            app.logger.error(f"Unexpected error during file upload: {str(e)}")
            app.logger.exception("Full traceback:")
            return jsonify({'error': f'An unexpected error occurred: {str(e)}'}), 500

    app.logger.error("Invalid file type")
    return jsonify({'error': 'Invalid file type'}), 400

def process_csv(file_path):
    cards = []
    app.logger.info(f"Starting to process CSV file: {file_path}")
    try:
        with open(file_path, 'r') as csvfile:
            reader = csv.DictReader(csvfile)
            app.logger.info(f"CSV headers: {reader.fieldnames}")
            headers = {h.lower(): h for h in reader.fieldnames}
            for row_num, row in enumerate(reader, start=1):
                app.logger.debug(f"Processing row {row_num}: {row}")
                name = row.get(headers.get('name', 'Name'), '').strip()
                set_code = row.get(headers.get('set', 'Set'), '').strip()
                if name and set_code:
                    cards.append({
                        'name': name,
                        'set': set_code,
                        'collector_number': row.get(headers.get('collector number', 'Collector Number'), '').strip()
                    })
                    app.logger.debug(f"Processed row {row_num}: {name} ({set_code})")
                else:
                    app.logger.warning(f"Skipping row {row_num} due to missing name or set: {row}")
    except Exception as e:
        app.logger.error(f"Error processing CSV file: {str(e)}")
        app.logger.exception("Full traceback:")
        raise

    app.logger.info(f"Finished processing CSV. Total cards processed: {len(cards)}")
    return cards

def fetch_card_data(cards):
    card_data = []
    for card in cards:
        try:
            response = requests.get(f"https://api.scryfall.com/cards/named?exact={card['name']}&set={card['set']}")
            response.raise_for_status()
            data = response.json()
            card_info = {
                'id': data['id'],
                'name': data['name'],
                'set': data['set'],
                'set_name': data['set_name'],
                'image_uris': data.get('image_uris', {}),
                'price': float(data['prices'].get('usd') or 0),
                'foil_price': float(data['prices'].get('usd_foil') or 0),
                'collector_number': data['collector_number'],
                'quantity': 1  # Default quantity
            }
            card_data.append(card_info)
        except requests.RequestException as e:
            app.logger.error(f"Error fetching card data from Scryfall: {str(e)}")
            # Add a placeholder for the card that couldn't be fetched
            card_data.append({
                'id': f"error_{len(card_data)}",
                'name': card['name'],
                'set': card['set'],
                'set_name': 'Unknown',
                'image_uris': {},
                'price': 0,
                'foil_price': 0,
                'collector_number': card.get('collector_number', 'Unknown'),
                'quantity': 1  # Default quantity
            })
    return card_data

import netifaces

@app.route('/api/get-local-ip', methods=['GET'])
def get_local_ip():
    try:
        interfaces = netifaces.interfaces()
        for iface in interfaces:
            addrs = netifaces.ifaddresses(iface)
            if netifaces.AF_INET in addrs:
                for addr in addrs[netifaces.AF_INET]:
                    ip = addr['addr']
                    # Exclude loopback and Docker addresses
                    if not ip.startswith('127.') and not ip.startswith('172.'):
                        return jsonify({'ip': ip})
        return jsonify({'error': 'No valid IP found'}), 500
    except Exception as e:
        app.logger.error(f"Error getting local IP: {str(e)}")
        return jsonify({'error': 'Unable to retrieve local IP'}), 500

@app.route('/', methods=['GET'])
def redirect_to_list():
    list_id = request.args.get('id')
    if list_id:
        return redirect(f'/card-list/{list_id}')
    return "No list ID provided", 400

@app.route('/api/card-list/<string:id>', methods=['GET'])
def serve_card_list(id):
    card_list = CardList.query.get(id)
    if card_list is None:
        return jsonify({"error": "Card list not found"}), 404
    
    items = CardListItem.query.filter_by(list_id=id).all()
    cards = [{
        "id": item.card_id,
        "name": item.name,
        "set": item.set_code,
        "set_name": item.set_name,
        "image_uris": json.loads(item.image_uris) if item.image_uris else {},
        "price": float(item.price) if item.price else 0,
        "foil_price": float(item.foil_price) if item.foil_price else 0,
        "collector_number": item.collector_number,
    } for item in items]
    
    return jsonify({
        "id": card_list.id,
        "name": card_list.name,
        "cards": cards
    })


@app.route('/api/health', methods=['GET'])
def health_check():
    # Check database connection
    try:
        db.session.execute(text("SELECT 1"))
        db_status = "healthy"
    except Exception as e:
        app.logger.error(f"Database health check failed: {str(e)}")
        db_status = "unhealthy"

    return jsonify({
        'status': 'healthy' if db_status == "healthy" else "unhealthy",
        'database': db_status
    })

if __name__ == '__main__':
    with app.app_context():
        # Remove db.create_all() and any schema changes to avoid altering the database
        setup_db_events(app)

    # Run the Flask app, accessible on your local network
    app.run(debug=True, host='0.0.0.0', port=5000)


==== .env ====

# .env

VITE_API_URL=http://localhost:5000/

==== .env.flask ====

# .env.flask

DATABASE_URI=postgresql://gluth:Caprisun1!@192.168.1.126:5432/mtg_collection_kiosk
SECRET_KEY=you-will-never-guess
FLASK_APP=main.py
# Redis configuration (remove if not using Redis)
# REDIS_HOST=localhost
# REDIS_PORT=6379
# REDIS_DB=0