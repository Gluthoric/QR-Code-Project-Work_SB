==== frontend/src/vite-env.d.ts ====

/// <reference types="vite/client" />

==== frontend/src/index.css ====

@tailwind base;
@tailwind components;
@tailwind utilities;
==== frontend/src/App.tsx ====

// src/App.tsx

import React, { useState } from 'react';
import { BrowserRouter as Router, Routes, Route, Navigate, useNavigate } from 'react-router-dom';
import FileUploader from './components/FileUploader';
import CardListWrapper from './components/CardListWrapper';
import { Card } from './types';

const API_URL = import.meta.env.VITE_API_URL || 'http://localhost:5000';
console.log('API_URL:', API_URL); // For debugging

// Home Component: Displays the File Uploader
function Home({ handleFileUpload }: { handleFileUpload: (file: File) => void }) {
  return (
    <div className="max-w-md mx-auto">
      <FileUploader onFileUpload={handleFileUpload} />
    </div>
  );
}

function App() {
  const [isLoading, setIsLoading] = useState(false);
  const navigate = useNavigate();

  const handleFileUpload = async (file: File) => {
    setIsLoading(true);
    try {
      const formData = new FormData();
      formData.append('file', file);

      const response = await fetch(`${API_URL}/api/upload`, {
        method: 'POST',
        body: formData,
      });

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }

      const result = await response.json();
      // Use navigate to redirect to the card list view
      navigate(`/card-list/${result.id}`);
    } catch (error) {
      console.error('Error processing file:', error);
      alert('Error processing file. Please try again.');
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <Router>
      <div className="min-h-screen bg-gray-100 p-8">
        <h1 className="text-4xl font-bold text-center mb-8">MTG Card Uploader</h1>
        <Routes>
          <Route path="/" element={<Home handleFileUpload={handleFileUpload} />} />
          <Route path="/card-list/:id" element={<CardListWrapper />} />
          <Route path="*" element={<Navigate to="/" replace />} />
        </Routes>
        {isLoading && (
          <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center">
            <div className="bg-white p-4 rounded-lg shadow-lg">
              <p className="text-lg font-semibold">Loading...</p>
            </div>
          </div>
        )}
      </div>
    </Router>
  );
}

export default App;

==== frontend/src/main.tsx ====

import { StrictMode } from 'react'
import { createRoot } from 'react-dom/client'
import App from './App.tsx'
import './index.css'

createRoot(document.getElementById('root')!).render(
  <StrictMode>
    <App />
  </StrictMode>,
)

==== frontend/src/types.ts ====

export interface CardData {
  id: string;
  name: string;
  set: string;
  price: number;
}

export interface Card {
  id: string;
  name: string;
  set: string;
  set_name: string;
  image_uris: {
    small: string;
    normal: string;
    large: string;
  };
  price: number;
  foil_price: number;
  collector_number: string;
}

export interface LocalAPICard {
  id: number;
  name: string;
  // Add other properties as needed for the local API response
}

==== frontend/src/components/CardGrid.tsx ====

import React from 'react';
import { Card } from '../types';

interface CardGridProps {
  cards: Card[];
}

const CardGrid: React.FC<CardGridProps> = ({ cards }) => {
  return (
    <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-6">
      {cards.map((card) => (
        <div key={card.id} className="bg-white rounded-lg shadow-md overflow-hidden flex flex-col">
          {card.image_uris?.normal && (
            <img src={card.image_uris.normal} alt={card.name} className="w-full h-auto object-cover" />
          )}
          <div className="p-4 text-center flex-grow flex flex-col justify-center">
            <h3 className="font-bold text-lg mb-2">{card.name}</h3>
            <p className="text-gray-600 mb-1">Set: {card.set_name} ({card.set})</p>
            <p className="text-gray-600 mb-1">Collector Number: {card.collector_number}</p>
            <p className="text-green-600 font-semibold mb-1">Price: ${card.price.toFixed(2)}</p>
            {card.foil_price && card.foil_price > 0 && (
              <p className="text-blue-600 font-semibold mb-1">Foil Price: ${card.foil_price.toFixed(2)}</p>
            )}
          </div>
        </div>
      ))}
    </div>
  );
};

export default CardGrid;
==== frontend/src/components/FileUploader.tsx ====

import React, { useCallback } from 'react';
import { useDropzone } from 'react-dropzone';
import { Upload } from 'lucide-react';

interface FileUploaderProps {
  onFileUpload: (file: File) => void;
}

export const FileUploader: React.FC<FileUploaderProps> = ({ onFileUpload }) => {
  const onDrop = useCallback((acceptedFiles: File[]) => {
    if (acceptedFiles.length > 0) {
      console.log('File accepted:', acceptedFiles[0].name);
      onFileUpload(acceptedFiles[0]);
    } else {
      console.log('No files were accepted');
    }
  }, [onFileUpload]);

  const { getRootProps, getInputProps, isDragActive, fileRejections } = useDropzone({
    onDrop,
    accept: {
      'text/csv': ['.csv'],
    },
    multiple: false,
  });

  console.log('FileRejections:', fileRejections);

  return (
    <div
      {...getRootProps()}
      className={`border-2 border-dashed rounded-lg p-8 text-center cursor-pointer transition-colors ${
        isDragActive ? 'border-blue-500 bg-blue-50' : 'border-gray-300 hover:border-gray-400'
      }`}
    >
      <input {...getInputProps()} />
      <Upload className="mx-auto h-12 w-12 text-gray-400" />
      <p className="mt-2 text-sm font-medium text-gray-900">
        {isDragActive ? 'Drop the CSV file here' : 'Drag & drop a CSV file here, or click to select one'}
      </p>
      <p className="mt-1 text-xs text-gray-500">
        CSV should contain columns: Scryfall ID, Name, Set Code, Price
      </p>
    </div>
  );
};

export default FileUploader;

==== frontend/src/components/QRCodeGenerator.tsx ====

// src/components/QRCodeGenerator.tsx

import React from 'react';
import { QRCodeSVG } from 'qrcode.react';

interface QRCodeGeneratorProps {
  url: string;
  name: string;
  onNameChange: (newName: string) => void;
}

const QRCodeGenerator: React.FC<QRCodeGeneratorProps> = ({ url, name, onNameChange }) => {
  const handleDownload = () => {
    const svg = document.getElementById('qr-code') as SVGSVGElement;
    const svgData = new XMLSerializer().serializeToString(svg);
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    const img = new Image();
    img.onload = () => {
      canvas.width = img.width;
      canvas.height = img.height + 30;
      ctx?.drawImage(img, 0, 0);

      if (ctx) {
        ctx.font = '16px Arial';
        ctx.fillStyle = 'black';
        ctx.textAlign = 'center';
        ctx.fillText(name, canvas.width / 2, canvas.height - 10);
      }

      const pngFile = canvas.toDataURL('image/png');
      const downloadLink = document.createElement('a');
      downloadLink.download = `${name || 'qrcode'}.png`;
      downloadLink.href = pngFile;
      downloadLink.click();
    };
    img.src = 'data:image/svg+xml;base64,' + btoa(svgData);
  };

  return (
    <div className="flex flex-col items-center space-y-4">
      <QRCodeSVG id="qr-code" value={url} size={200} />
      <p className="text-lg font-semibold">Scan to view card list</p>
      <input
        type="text"
        value={name}
        onChange={(e) => onNameChange(e.target.value)}
        placeholder="Enter QR code name"
        className="border border-gray-300 rounded px-3 py-2 w-full max-w-xs"
      />
      <button
        onClick={handleDownload}
        className="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded"
      >
        Download QR Code
      </button>
    </div>
  );
};

export default QRCodeGenerator;

==== frontend/src/components/CardList.tsx ====

import React, { useState, useEffect } from 'react';
import QRCodeGenerator from './QRCodeGenerator';
import CardGrid from './CardGrid';
import { Card } from '../types';

const API_URL = import.meta.env.VITE_API_URL || 'http://localhost:5000';

interface CardListProps {
  listId: string;
  listName: string;
  setListName: (name: string) => void;
}

const CardList: React.FC<CardListProps> = ({ listId, listName, setListName }) => {
  const [cards, setCards] = useState<Card[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [localIpAddress, setLocalIpAddress] = useState('');

  useEffect(() => {
    const fetchLocalIpAddress = async () => {
      try {
        const response = await fetch(`${API_URL}/api/get-local-ip`);
        if (response.ok) {
          const data = await response.json();
          console.log('Fetched local IP address:', data.ip);
          setLocalIpAddress(data.ip);
        } else {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
      } catch (error) {
        console.error('Error fetching local IP address:', error);
        setLocalIpAddress('localhost'); // Fallback to localhost if unable to fetch IP
      }
    };

    const fetchCardList = async () => {
      setIsLoading(true);
      try {
        const response = await fetch(`${API_URL}/api/card-list/${listId}`);
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        const data = await response.json();
        setCards(data.cards);
        setListName(data.name);
      } catch (error) {
        console.error('Error fetching card list:', error);
        alert('Error fetching card list. Please try again.');
      } finally {
        setIsLoading(false);
      }
    };

    fetchLocalIpAddress();
    fetchCardList();
  }, [listId, setListName]);

  const handleNameChange = async (newName: string) => {
    setListName(newName);
    try {
      const response = await fetch(`${API_URL}/api/card-list/${listId}`, {
        method: 'PATCH',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ name: newName }),
      });

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      console.error('Error updating list name:', error);
      alert('Error updating list name. Please try again.');
    }
  };

  return (
    <div className="space-y-8">
      <QRCodeGenerator
        url={`http://${localIpAddress}/card-list/${listId}`}
        name={listName}
        onNameChange={handleNameChange}
      />
      <CardGrid cards={cards} />
      {isLoading && (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center">
          <div className="bg-white p-4 rounded-lg shadow-lg">
            <p className="text-lg font-semibold">Loading...</p>
          </div>
        </div>
      )}
    </div>
  );
};

export default CardList;

==== frontend/src/components/CardListWrapper.tsx ====

import React, { useState } from 'react';
import { useParams, Navigate } from 'react-router-dom';
import CardList from './CardList';

function CardListWrapper() {
  const { id } = useParams<{ id: string }>();
  const [listName, setListName] = useState('');

  if (!id) {
    return <Navigate to="/" replace />;
  }

  return <CardList listId={id} listName={listName} setListName={setListName} />;
}

export default CardListWrapper;

==== frontend/src/utils/api.ts ====

import { CardData, Card, LocalAPICard } from '../types';

const SCRYFALL_API = 'https://api.scryfall.com/cards';
const LOCAL_API = import.meta.env.VITE_API_URL;

export const fetchCardData = async (cards: CardData[]): Promise<Card[]> => {
  const fetchPromises = cards.map(async (card) => {
    if (!card.id) {
      console.warn(`Skipping card with missing ID: ${card.name}`);
      return null;
    }
    try {
      const response = await fetch(`${SCRYFALL_API}/${card.id}`);
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      return {
        id: data.id,
        name: data.name,
        set: data.set,
        set_name: data.set_name,
        image_uris: data.image_uris,
        price: parseFloat(data.prices.usd || '0'),
        foil_price: parseFloat(data.prices.usd_foil || '0'),
        collector_number: data.collector_number,
      } as Card;
    } catch (error) {
      console.error(`Error fetching data for card ${card.name || 'Unknown'}:`, error);
      return null;
    }
  });

  return (await Promise.all(fetchPromises)).filter((card): card is Card => card !== null);
};

// New functions for interacting with our local Flask API

export const getCardsFromLocalAPI = async (): Promise<LocalAPICard[]> => {
  try {
    const response = await fetch(`${LOCAL_API}/cards`);
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    return await response.json();
  } catch (error) {
    console.error('Error fetching cards from local API:', error);
    return [];
  }
};

export const testRedisConnection = async (): Promise<string | null> => {
  try {
    const response = await fetch(`${LOCAL_API}/redis-test`);
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    const data = await response.json();
    return data.redis_value;
  } catch (error) {
    console.error('Error testing Redis connection:', error);
    return null;
  }
};

==== frontend/src/utils/csvProcessor.ts ====

import Papa from 'papaparse';
import { CardData } from '../types';

export const processCSV = (file: File): Promise<CardData[]> => {
  return new Promise((resolve, reject) => {
    Papa.parse(file, {
      header: true,
      complete: (results) => {
        const cards: CardData[] = results.data
          .filter((row: any) => row['Scryfall ID'] && row['Name'])
          .map((row: any) => ({
            id: row['Scryfall ID'],
            name: row['Name'],
            set: row['Set Code'] || '',
            price: parseFloat(row['Price']) || 0,
          }));
        if (cards.length === 0) {
          reject(new Error('No valid card data found in the CSV file.'));
        } else {
          resolve(cards);
        }
      },
      error: (error) => {
        reject(new Error(`Error parsing CSV: ${error.message}`));
      },
    });
  });
};
==== frontend/src/utils/database.ts ====

import { Pool } from 'pg';

// Note: This is not a recommended approach for production applications.
// Ideally, database operations should be handled by a separate backend service.
const pool = new Pool({
  connectionString: import.meta.env.VITE_DATABASE_URI,
});

export const query = (text: string, params: any[]) => pool.query(text, params);

export const getClient = () => pool.connect();

console.warn('Warning: Direct database access from the frontend is not recommended for production use.');

==== .env.flask ====

# .env.flask

DATABASE_URI=postgresql://gluth:Caprisun1!@192.168.1.126:5432/mtg_collection_kiosk
SECRET_KEY=you-will-never-guess
FLASK_APP=main.py
# Redis configuration (remove if not using Redis)
# REDIS_HOST=localhost
# REDIS_PORT=6379
# REDIS_DB=0
==== frontend/.env ====

# .env

VITE_API_URL=http://192.168.1.207:5000/

==== main.py ====

# main.py

import os
from flask import Flask, jsonify, request, send_from_directory
from flask_sqlalchemy import SQLAlchemy
from flask_cors import CORS
from dotenv import load_dotenv
import uuid
from werkzeug.utils import secure_filename
import csv
import requests
from sqlalchemy import event, text, CHAR
from sqlalchemy.exc import SQLAlchemyError, OperationalError
from sqlalchemy.orm import relationship
import json
import logging
import netifaces

# Load environment variables from .env.flask
load_dotenv('.env.flask')

# Initialize Flask with absolute path for static_folder
app = Flask(
    __name__,
    static_folder=os.path.join(os.path.dirname(__file__), 'frontend', 'dist'),
    static_url_path=''
)
app.logger.debug(f"Static folder path set to: {app.static_folder}")

CORS(app)  # Enable CORS for all routes
logging.basicConfig(level=logging.DEBUG, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')

# Configure SQLAlchemy
app.config['SQLALCHEMY_DATABASE_URI'] = os.getenv('DATABASE_URI')
app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False
app.config['SECRET_KEY'] = os.getenv('SECRET_KEY')

db = SQLAlchemy(app)

# Define models
class CardList(db.Model):
    __tablename__ = 'card_lists'
    id = db.Column(CHAR(36), primary_key=True)
    name = db.Column(db.String(255), nullable=False)
    items = relationship('CardListItem', back_populates='card_list', cascade="all, delete-orphan")

class CardListItem(db.Model):
    __tablename__ = 'card_list_items'
    list_id = db.Column(CHAR(36), db.ForeignKey('card_lists.id'), primary_key=True)
    card_id = db.Column(db.Text, primary_key=True)
    name = db.Column(db.String(255), nullable=False)
    set_code = db.Column(db.String(10), nullable=False)
    set_name = db.Column(db.String(255), nullable=False)
    collector_number = db.Column(db.String(20), nullable=False)
    image_uris = db.Column(db.JSON)
    price = db.Column(db.Numeric(10, 2))
    foil_price = db.Column(db.Numeric(10, 2))
    quantity = db.Column(db.Integer, default=1)  # New field for quantity
    card_list = relationship('CardList', back_populates='items')

def setup_db_events(app):
    @event.listens_for(db.engine, "engine_connect")
    def ping_connection(conn):
        try:
            conn.scalar(text("SELECT 1"))
        except Exception:
            app.logger.warning("Database connection failed. Invalidating connection.")
            conn.invalidate()

# Global error handler for database errors
@app.errorhandler(SQLAlchemyError)
def handle_db_error(error):
    app.logger.error(f"Database error: {str(error)}")
    return jsonify({'error': 'An error occurred while processing your request.'}), 500

@app.errorhandler(OperationalError)
def handle_operational_error(error):
    app.logger.error(f"Database connection error: {str(error)}")
    return jsonify({'error': 'Database connection error. Please try again later.'}), 503

# API routes

@app.route('/api/card-list/<string:id>', methods=['GET'])
def get_card_list(id):
    try:
        card_list = CardList.query.get(id)
        if not card_list:
            return jsonify({'error': 'Card list not found'}), 404

        items = CardListItem.query.filter_by(list_id=id).all()
        cards = [{
            "id": item.card_id,
            "name": item.name,
            "set": item.set_code,
            "set_name": item.set_name,
            "image_uris": item.image_uris or {},
            "price": float(item.price) if item.price else 0,
            "foil_price": float(item.foil_price) if item.foil_price else 0,
            "collector_number": item.collector_number,
            "quantity": item.quantity
        } for item in items]

        return jsonify({
            "id": card_list.id,
            "name": card_list.name,
            "cards": cards
        })
    except Exception as e:
        db.session.rollback()
        app.logger.error(f"Error: {str(e)}")
        return jsonify({'error': 'An error occurred'}), 500

@app.route('/api/card-list/<string:id>', methods=['PATCH'])
def update_card_list_name(id):
    try:
        card_list = db.session.query(CardList).get(id)
        if not card_list:
            return jsonify({'error': 'Card list not found'}), 404

        data = request.json
        if 'name' in data:
            card_list.name = data['name']
            db.session.commit()
            return jsonify({'message': 'Card list name updated successfully'})
        return jsonify({'error': 'Name not provided'}), 400
    except Exception as e:
        db.session.rollback()
        app.logger.error(f"Error: {str(e)}")
        return jsonify({'error': 'An error occurred'}), 500

@app.route('/api/upload', methods=['POST'])
def upload_file():
    app.logger.info("Upload request received")
    app.logger.debug(f"Request files: {request.files}")
    app.logger.debug(f"Request form: {request.form}")

    if 'file' not in request.files:
        app.logger.error("No file part in the request")
        return jsonify({'error': 'No file part'}), 400

    file = request.files['file']
    app.logger.info(f"File received: {file.filename}")

    if file.filename == '':
        app.logger.error("No selected file")
        return jsonify({'error': 'No selected file'}), 400

    if file and file.filename.endswith('.csv'):
        try:
            filename = secure_filename(file.filename)
            file_path = os.path.join('/tmp', filename)
            file.save(file_path)
            app.logger.info(f"File saved to {file_path}")

            cards = process_csv(file_path)
            app.logger.info(f"Processed {len(cards)} cards from CSV")

            card_data = fetch_card_data(cards)
            app.logger.info(f"Fetched data for {len(card_data)} cards")

            list_id = str(uuid.uuid4())
            list_name = f"Card List {list_id[:8]}"
            new_list = CardList(id=list_id, name=list_name)
            db.session.add(new_list)
            app.logger.info(f"Created new CardList: {list_id}")

            for card_info in card_data:
                try:
                    existing_item = CardListItem.query.filter_by(list_id=list_id, card_id=card_info['id']).first()
                    if existing_item:
                        existing_item.quantity += 1
                    else:
                        card_list_item = CardListItem(
                            list_id=list_id,
                            card_id=card_info['id'],
                            name=card_info['name'],
                            set_code=card_info['set'],
                            set_name=card_info['set_name'],
                            collector_number=card_info['collector_number'],
                            image_uris=card_info['image_uris'],
                            price=card_info['price'],
                            foil_price=card_info['foil_price'],
                            quantity=1
                        )
                        db.session.add(card_list_item)
                except SQLAlchemyError as e:
                    app.logger.error(f"Error adding CardListItem: {str(e)}")
                    db.session.rollback()
                    return jsonify({'error': f'Error adding card to list: {str(e)}'}), 500

            try:
                db.session.commit()
                app.logger.info(f"Committed changes to database")
            except SQLAlchemyError as e:
                app.logger.error(f"Error committing to database: {str(e)}")
                db.session.rollback()
                return jsonify({'error': f'Error saving to database: {str(e)}'}), 500

            os.remove(file_path)
            app.logger.info(f"Temporary file {file_path} removed")

            return jsonify({
                'id': list_id,
                'name': list_name,
                'cards': card_data
            })
        except Exception as e:
            db.session.rollback()
            app.logger.error(f"Unexpected error during file upload: {str(e)}")
            app.logger.exception("Full traceback:")
            return jsonify({'error': f'An unexpected error occurred: {str(e)}'}), 500

    app.logger.error("Invalid file type")
    return jsonify({'error': 'Invalid file type'}), 400

def process_csv(file_path):
    cards = []
    app.logger.info(f"Starting to process CSV file: {file_path}")
    try:
        with open(file_path, 'r') as csvfile:
            reader = csv.DictReader(csvfile)
            app.logger.info(f"CSV headers: {reader.fieldnames}")
            headers = {h.lower(): h for h in reader.fieldnames}
            for row_num, row in enumerate(reader, start=1):
                app.logger.debug(f"Processing row {row_num}: {row}")
                name = row.get(headers.get('name', 'Name'), '').strip()
                set_code = row.get(headers.get('set', 'Set'), '').strip()
                if name and set_code:
                    cards.append({
                        'name': name,
                        'set': set_code,
                        'collector_number': row.get(headers.get('collector number', 'Collector Number'), '').strip()
                    })
                    app.logger.debug(f"Processed row {row_num}: {name} ({set_code})")
                else:
                    app.logger.warning(f"Skipping row {row_num} due to missing name or set: {row}")
    except Exception as e:
        app.logger.error(f"Error processing CSV file: {str(e)}")
        app.logger.exception("Full traceback:")
        raise

    app.logger.info(f"Finished processing CSV. Total cards processed: {len(cards)}")
    return cards

def fetch_card_data(cards):
    card_data = []
    for card in cards:
        try:
            response = requests.get(f"https://api.scryfall.com/cards/named?exact={card['name']}&set={card['set']}")
            response.raise_for_status()
            data = response.json()
            card_info = {
                'id': data['id'],
                'name': data['name'],
                'set': data['set'],
                'set_name': data['set_name'],
                'image_uris': data.get('image_uris', {}),
                'price': float(data['prices'].get('usd') or 0),
                'foil_price': float(data['prices'].get('usd_foil') or 0),
                'collector_number': data['collector_number'],
                'quantity': 1  # Default quantity
            }
            card_data.append(card_info)
        except requests.RequestException as e:
            app.logger.error(f"Error fetching card data from Scryfall: {str(e)}")
            # Add a placeholder for the card that couldn't be fetched
            card_data.append({
                'id': f"error_{len(card_data)}",
                'name': card['name'],
                'set': card['set'],
                'set_name': 'Unknown',
                'image_uris': {},
                'price': 0,
                'foil_price': 0,
                'collector_number': card.get('collector_number', 'Unknown'),
                'quantity': 1  # Default quantity
            })
    return card_data

@app.route('/api/get-local-ip', methods=['GET'])
def get_local_ip():
    try:
        interfaces = netifaces.interfaces()
        for iface in interfaces:
            addrs = netifaces.ifaddresses(iface)
            if netifaces.AF_INET in addrs:
                for addr in addrs[netifaces.AF_INET]:
                    ip = addr['addr']
                    # Exclude loopback and Docker addresses
                    if not ip.startswith('127.') and not ip.startswith('172.'):
                        return jsonify({'ip': ip})
        return jsonify({'error': 'No valid IP found'}), 500
    except Exception as e:
        app.logger.error(f"Error getting local IP: {str(e)}")
        return jsonify({'error': 'Unable to retrieve local IP'}), 500

@app.route('/api/health', methods=['GET'])
def health_check():
    # Check database connection
    try:
        db.session.execute(text("SELECT 1"))
        db_status = "healthy"
    except Exception as e:
        app.logger.error(f"Database health check failed: {str(e)}")
        db_status = "unhealthy"

    return jsonify({
        'status': 'healthy' if db_status == "healthy" else "unhealthy",
        'database': db_status
    })

# Serve React App (must be after API routes to avoid conflicts)
@app.route('/', defaults={'path': ''})
@app.route('/<path:path>')
def serve_react_app(path):
    if path != "" and os.path.exists(os.path.join(app.static_folder, path)):
        app.logger.debug(f"Serving static file: {path}")
        return send_from_directory(app.static_folder, path)
    else:
        app.logger.debug("Serving index.html")
        return send_from_directory(app.static_folder, 'index.html')


if __name__ == '__main__':
    with app.app_context():
        setup_db_events(app)
    # Run the Flask app, accessible on your local network
    app.run(debug=True, host='0.0.0.0', port=5000)

